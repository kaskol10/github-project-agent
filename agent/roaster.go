package agent

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/kaskol10/github-project-agent/github"
	"github.com/kaskol10/github-project-agent/llm"
	"github.com/kaskol10/github-project-agent/prompts"
)

type Roaster struct {
	githubClient github.UnifiedClient
	llmClient    *llm.Client
	promptLoader *prompts.Loader
}

func NewRoaster(ghClient github.UnifiedClient, llmClient *llm.Client) *Roaster {
	// Try to load prompts from prompts/ directory
	promptPath := getPromptPath("prompts")
	promptLoader, _ := prompts.NewLoader(promptPath) // Ignore error, will use fallback

	return &Roaster{
		githubClient: ghClient,
		llmClient:    llmClient,
		promptLoader: promptLoader,
	}
}

func (r *Roaster) RoastAndSuggest(ctx context.Context) error {
	// Get all issues
	allIssues, err := r.githubClient.ListIssues(ctx, "all")
	if err != nil {
		return fmt.Errorf("failed to list issues: %w", err)
	}

	// Analyze the product/roadmap
	analysis, suggestions, err := r.analyzeProduct(ctx, allIssues)
	if err != nil {
		return fmt.Errorf("failed to analyze product: %w", err)
	}

	// Create a new issue with the roast and suggestions
	title := fmt.Sprintf("ðŸ¤– Product Roast & Roadmap Suggestions - %s", time.Now().Format("2006-01-02"))
	body := fmt.Sprintf(`# Product Roast & Roadmap Analysis

## ðŸ”¥ The Roast

%s

## ðŸ’¡ Suggested Tasks

%s

---
*Generated by the GitHub Project Agent on %s*`,
		analysis,
		suggestions,
		time.Now().Format("2006-01-02 15:04:05"),
	)

	labels := []string{"agent-generated", "roadmap", "analysis"}

	// In project mode, CreateIssue will use the first repository if owner/repo are empty
	// In repo mode, owner/repo are ignored
	owner, repo := "", ""
	_, err = r.githubClient.CreateIssue(ctx, owner, repo, title, body, labels)
	if err != nil {
		return fmt.Errorf("failed to create roast issue: %w", err)
	}

	return nil
}

func (r *Roaster) analyzeProduct(ctx context.Context, issues []*github.Issue) (string, string, error) {
	// Prepare context about the issues
	issueSummary := r.summarizeIssues(issues)

	// Try to use template, fallback to hardcoded prompt
	var prompt string
	if r.promptLoader != nil && r.promptLoader.HasTemplate("roaster") {
		data := map[string]interface{}{
			"TotalIssues":  len(issues),
			"OpenIssues":   r.countByState(issues, "open"),
			"ClosedIssues": r.countByState(issues, "closed"),
			"IssueSummary": issueSummary,
		}

		rendered, err := r.promptLoader.Render("roaster", data)
		if err == nil {
			prompt = rendered
		}
	}

	// Fallback to hardcoded prompt if template not available
	if prompt == "" {
		prompt = fmt.Sprintf(`You are a brutally honest product advisor. Analyze this GitHub project and provide:

1. A "roast" - honest, constructive criticism about the product, roadmap, and task management. Be direct but professional. Point out gaps, inconsistencies, and areas for improvement.

2. Specific, actionable task suggestions for the roadmap. Format each suggestion as:
   - **Title**: [Task title]
   - **Description**: [Detailed description]
   - **Priority**: [High/Medium/Low]
   - **Rationale**: [Why this is important]

Project context:
- Total issues: %d
- Open issues: %d
- Closed issues: %d
- Issue breakdown: %s

Provide your analysis in this exact format:

## ROAST:
[Your roast here]

## SUGGESTIONS:
[Your suggestions here, one per task]

Be specific, actionable, and honest.`,
			len(issues),
			r.countByState(issues, "open"),
			r.countByState(issues, "closed"),
			issueSummary,
		)
	}

	response, err := r.llmClient.Prompt(prompt)
	if err != nil {
		return "", "", err
	}

	// Parse the response
	parts := strings.Split(response, "## SUGGESTIONS:")
	if len(parts) < 2 {
		return response, "Could not parse suggestions from LLM response", nil
	}

	roast := strings.TrimSpace(strings.TrimPrefix(parts[0], "## ROAST:"))
	suggestions := strings.TrimSpace(parts[1])

	return roast, suggestions, nil
}

func (r *Roaster) summarizeIssues(issues []*github.Issue) string {
	if len(issues) == 0 {
		return "No issues found"
	}

	// Count by labels
	labelCounts := make(map[string]int)
	for _, issue := range issues {
		for _, label := range issue.Labels {
			labelCounts[label]++
		}
	}

	// Get top labels
	topLabels := make([]string, 0, 5)
	for label, count := range labelCounts {
		if count > 0 {
			topLabels = append(topLabels, fmt.Sprintf("%s (%d)", label, count))
		}
		if len(topLabels) >= 5 {
			break
		}
	}

	// Calculate average age
	var totalAge time.Duration
	for _, issue := range issues {
		if issue.State == "open" {
			totalAge += time.Since(issue.CreatedAt)
		}
	}
	avgAgeDays := 0.0
	openCount := r.countByState(issues, "open")
	if openCount > 0 {
		avgAgeDays = totalAge.Hours() / 24 / float64(openCount)
	}

	return fmt.Sprintf("Top labels: %s | Avg open issue age: %.1f days",
		strings.Join(topLabels, ", "), avgAgeDays)
}

func (r *Roaster) countByState(issues []*github.Issue, state string) int {
	count := 0
	for _, issue := range issues {
		if issue.State == state {
			count++
		}
	}
	return count
}
